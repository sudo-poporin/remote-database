// dart format width=80
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'remote_database_exceptions.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;
/// @nodoc
mixin _$RemoteDatabaseExceptions {

 dynamic get error;
/// Create a copy of RemoteDatabaseExceptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$RemoteDatabaseExceptionsCopyWith<RemoteDatabaseExceptions> get copyWith => _$RemoteDatabaseExceptionsCopyWithImpl<RemoteDatabaseExceptions>(this as RemoteDatabaseExceptions, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is RemoteDatabaseExceptions&&const DeepCollectionEquality().equals(other.error, error));
}


@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(error));

@override
String toString() {
  return 'RemoteDatabaseExceptions(error: $error)';
}


}

/// @nodoc
abstract mixin class $RemoteDatabaseExceptionsCopyWith<$Res>  {
  factory $RemoteDatabaseExceptionsCopyWith(RemoteDatabaseExceptions value, $Res Function(RemoteDatabaseExceptions) _then) = _$RemoteDatabaseExceptionsCopyWithImpl;
@useResult
$Res call({
 dynamic error
});




}
/// @nodoc
class _$RemoteDatabaseExceptionsCopyWithImpl<$Res>
    implements $RemoteDatabaseExceptionsCopyWith<$Res> {
  _$RemoteDatabaseExceptionsCopyWithImpl(this._self, this._then);

  final RemoteDatabaseExceptions _self;
  final $Res Function(RemoteDatabaseExceptions) _then;

/// Create a copy of RemoteDatabaseExceptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? error = freezed,}) {
  return _then(_self.copyWith(
error: freezed == error ? _self.error : error // ignore: cast_nullable_to_non_nullable
as dynamic,
  ));
}

}


/// @nodoc


class _RemoteDatabaseInsertFailure implements RemoteDatabaseExceptions {
  const _RemoteDatabaseInsertFailure([this.error]);
  

@override final  dynamic error;

/// Create a copy of RemoteDatabaseExceptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$RemoteDatabaseInsertFailureCopyWith<_RemoteDatabaseInsertFailure> get copyWith => __$RemoteDatabaseInsertFailureCopyWithImpl<_RemoteDatabaseInsertFailure>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _RemoteDatabaseInsertFailure&&const DeepCollectionEquality().equals(other.error, error));
}


@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(error));

@override
String toString() {
  return 'RemoteDatabaseExceptions.insertFailure(error: $error)';
}


}

/// @nodoc
abstract mixin class _$RemoteDatabaseInsertFailureCopyWith<$Res> implements $RemoteDatabaseExceptionsCopyWith<$Res> {
  factory _$RemoteDatabaseInsertFailureCopyWith(_RemoteDatabaseInsertFailure value, $Res Function(_RemoteDatabaseInsertFailure) _then) = __$RemoteDatabaseInsertFailureCopyWithImpl;
@override @useResult
$Res call({
 dynamic error
});




}
/// @nodoc
class __$RemoteDatabaseInsertFailureCopyWithImpl<$Res>
    implements _$RemoteDatabaseInsertFailureCopyWith<$Res> {
  __$RemoteDatabaseInsertFailureCopyWithImpl(this._self, this._then);

  final _RemoteDatabaseInsertFailure _self;
  final $Res Function(_RemoteDatabaseInsertFailure) _then;

/// Create a copy of RemoteDatabaseExceptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? error = freezed,}) {
  return _then(_RemoteDatabaseInsertFailure(
freezed == error ? _self.error : error // ignore: cast_nullable_to_non_nullable
as dynamic,
  ));
}


}

/// @nodoc


class _RemoteDatabaseUpdateFailure implements RemoteDatabaseExceptions {
  const _RemoteDatabaseUpdateFailure([this.error]);
  

@override final  dynamic error;

/// Create a copy of RemoteDatabaseExceptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$RemoteDatabaseUpdateFailureCopyWith<_RemoteDatabaseUpdateFailure> get copyWith => __$RemoteDatabaseUpdateFailureCopyWithImpl<_RemoteDatabaseUpdateFailure>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _RemoteDatabaseUpdateFailure&&const DeepCollectionEquality().equals(other.error, error));
}


@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(error));

@override
String toString() {
  return 'RemoteDatabaseExceptions.updateFailure(error: $error)';
}


}

/// @nodoc
abstract mixin class _$RemoteDatabaseUpdateFailureCopyWith<$Res> implements $RemoteDatabaseExceptionsCopyWith<$Res> {
  factory _$RemoteDatabaseUpdateFailureCopyWith(_RemoteDatabaseUpdateFailure value, $Res Function(_RemoteDatabaseUpdateFailure) _then) = __$RemoteDatabaseUpdateFailureCopyWithImpl;
@override @useResult
$Res call({
 dynamic error
});




}
/// @nodoc
class __$RemoteDatabaseUpdateFailureCopyWithImpl<$Res>
    implements _$RemoteDatabaseUpdateFailureCopyWith<$Res> {
  __$RemoteDatabaseUpdateFailureCopyWithImpl(this._self, this._then);

  final _RemoteDatabaseUpdateFailure _self;
  final $Res Function(_RemoteDatabaseUpdateFailure) _then;

/// Create a copy of RemoteDatabaseExceptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? error = freezed,}) {
  return _then(_RemoteDatabaseUpdateFailure(
freezed == error ? _self.error : error // ignore: cast_nullable_to_non_nullable
as dynamic,
  ));
}


}

/// @nodoc


class _RemoteDatabaseUpsertFailure implements RemoteDatabaseExceptions {
  const _RemoteDatabaseUpsertFailure([this.error]);
  

@override final  dynamic error;

/// Create a copy of RemoteDatabaseExceptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$RemoteDatabaseUpsertFailureCopyWith<_RemoteDatabaseUpsertFailure> get copyWith => __$RemoteDatabaseUpsertFailureCopyWithImpl<_RemoteDatabaseUpsertFailure>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _RemoteDatabaseUpsertFailure&&const DeepCollectionEquality().equals(other.error, error));
}


@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(error));

@override
String toString() {
  return 'RemoteDatabaseExceptions.upsertFailure(error: $error)';
}


}

/// @nodoc
abstract mixin class _$RemoteDatabaseUpsertFailureCopyWith<$Res> implements $RemoteDatabaseExceptionsCopyWith<$Res> {
  factory _$RemoteDatabaseUpsertFailureCopyWith(_RemoteDatabaseUpsertFailure value, $Res Function(_RemoteDatabaseUpsertFailure) _then) = __$RemoteDatabaseUpsertFailureCopyWithImpl;
@override @useResult
$Res call({
 dynamic error
});




}
/// @nodoc
class __$RemoteDatabaseUpsertFailureCopyWithImpl<$Res>
    implements _$RemoteDatabaseUpsertFailureCopyWith<$Res> {
  __$RemoteDatabaseUpsertFailureCopyWithImpl(this._self, this._then);

  final _RemoteDatabaseUpsertFailure _self;
  final $Res Function(_RemoteDatabaseUpsertFailure) _then;

/// Create a copy of RemoteDatabaseExceptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? error = freezed,}) {
  return _then(_RemoteDatabaseUpsertFailure(
freezed == error ? _self.error : error // ignore: cast_nullable_to_non_nullable
as dynamic,
  ));
}


}

/// @nodoc


class _RemoteDatabaseDeleteFailure implements RemoteDatabaseExceptions {
  const _RemoteDatabaseDeleteFailure([this.error]);
  

@override final  dynamic error;

/// Create a copy of RemoteDatabaseExceptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$RemoteDatabaseDeleteFailureCopyWith<_RemoteDatabaseDeleteFailure> get copyWith => __$RemoteDatabaseDeleteFailureCopyWithImpl<_RemoteDatabaseDeleteFailure>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _RemoteDatabaseDeleteFailure&&const DeepCollectionEquality().equals(other.error, error));
}


@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(error));

@override
String toString() {
  return 'RemoteDatabaseExceptions.deleteFailure(error: $error)';
}


}

/// @nodoc
abstract mixin class _$RemoteDatabaseDeleteFailureCopyWith<$Res> implements $RemoteDatabaseExceptionsCopyWith<$Res> {
  factory _$RemoteDatabaseDeleteFailureCopyWith(_RemoteDatabaseDeleteFailure value, $Res Function(_RemoteDatabaseDeleteFailure) _then) = __$RemoteDatabaseDeleteFailureCopyWithImpl;
@override @useResult
$Res call({
 dynamic error
});




}
/// @nodoc
class __$RemoteDatabaseDeleteFailureCopyWithImpl<$Res>
    implements _$RemoteDatabaseDeleteFailureCopyWith<$Res> {
  __$RemoteDatabaseDeleteFailureCopyWithImpl(this._self, this._then);

  final _RemoteDatabaseDeleteFailure _self;
  final $Res Function(_RemoteDatabaseDeleteFailure) _then;

/// Create a copy of RemoteDatabaseExceptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? error = freezed,}) {
  return _then(_RemoteDatabaseDeleteFailure(
freezed == error ? _self.error : error // ignore: cast_nullable_to_non_nullable
as dynamic,
  ));
}


}

/// @nodoc


class _RemoteDatabaseSelectFailure implements RemoteDatabaseExceptions {
  const _RemoteDatabaseSelectFailure([this.error]);
  

@override final  dynamic error;

/// Create a copy of RemoteDatabaseExceptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$RemoteDatabaseSelectFailureCopyWith<_RemoteDatabaseSelectFailure> get copyWith => __$RemoteDatabaseSelectFailureCopyWithImpl<_RemoteDatabaseSelectFailure>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _RemoteDatabaseSelectFailure&&const DeepCollectionEquality().equals(other.error, error));
}


@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(error));

@override
String toString() {
  return 'RemoteDatabaseExceptions.selectFailure(error: $error)';
}


}

/// @nodoc
abstract mixin class _$RemoteDatabaseSelectFailureCopyWith<$Res> implements $RemoteDatabaseExceptionsCopyWith<$Res> {
  factory _$RemoteDatabaseSelectFailureCopyWith(_RemoteDatabaseSelectFailure value, $Res Function(_RemoteDatabaseSelectFailure) _then) = __$RemoteDatabaseSelectFailureCopyWithImpl;
@override @useResult
$Res call({
 dynamic error
});




}
/// @nodoc
class __$RemoteDatabaseSelectFailureCopyWithImpl<$Res>
    implements _$RemoteDatabaseSelectFailureCopyWith<$Res> {
  __$RemoteDatabaseSelectFailureCopyWithImpl(this._self, this._then);

  final _RemoteDatabaseSelectFailure _self;
  final $Res Function(_RemoteDatabaseSelectFailure) _then;

/// Create a copy of RemoteDatabaseExceptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? error = freezed,}) {
  return _then(_RemoteDatabaseSelectFailure(
freezed == error ? _self.error : error // ignore: cast_nullable_to_non_nullable
as dynamic,
  ));
}


}

/// @nodoc


class _RemoteDatabaseSelectSingleFailure implements RemoteDatabaseExceptions {
  const _RemoteDatabaseSelectSingleFailure([this.error]);
  

@override final  dynamic error;

/// Create a copy of RemoteDatabaseExceptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$RemoteDatabaseSelectSingleFailureCopyWith<_RemoteDatabaseSelectSingleFailure> get copyWith => __$RemoteDatabaseSelectSingleFailureCopyWithImpl<_RemoteDatabaseSelectSingleFailure>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _RemoteDatabaseSelectSingleFailure&&const DeepCollectionEquality().equals(other.error, error));
}


@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(error));

@override
String toString() {
  return 'RemoteDatabaseExceptions.selectSingleFailure(error: $error)';
}


}

/// @nodoc
abstract mixin class _$RemoteDatabaseSelectSingleFailureCopyWith<$Res> implements $RemoteDatabaseExceptionsCopyWith<$Res> {
  factory _$RemoteDatabaseSelectSingleFailureCopyWith(_RemoteDatabaseSelectSingleFailure value, $Res Function(_RemoteDatabaseSelectSingleFailure) _then) = __$RemoteDatabaseSelectSingleFailureCopyWithImpl;
@override @useResult
$Res call({
 dynamic error
});




}
/// @nodoc
class __$RemoteDatabaseSelectSingleFailureCopyWithImpl<$Res>
    implements _$RemoteDatabaseSelectSingleFailureCopyWith<$Res> {
  __$RemoteDatabaseSelectSingleFailureCopyWithImpl(this._self, this._then);

  final _RemoteDatabaseSelectSingleFailure _self;
  final $Res Function(_RemoteDatabaseSelectSingleFailure) _then;

/// Create a copy of RemoteDatabaseExceptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? error = freezed,}) {
  return _then(_RemoteDatabaseSelectSingleFailure(
freezed == error ? _self.error : error // ignore: cast_nullable_to_non_nullable
as dynamic,
  ));
}


}

/// @nodoc


class _RemoteDatabaseNoDataFound implements RemoteDatabaseExceptions {
  const _RemoteDatabaseNoDataFound([this.error]);
  

@override final  dynamic error;

/// Create a copy of RemoteDatabaseExceptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$RemoteDatabaseNoDataFoundCopyWith<_RemoteDatabaseNoDataFound> get copyWith => __$RemoteDatabaseNoDataFoundCopyWithImpl<_RemoteDatabaseNoDataFound>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _RemoteDatabaseNoDataFound&&const DeepCollectionEquality().equals(other.error, error));
}


@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(error));

@override
String toString() {
  return 'RemoteDatabaseExceptions.noDataFound(error: $error)';
}


}

/// @nodoc
abstract mixin class _$RemoteDatabaseNoDataFoundCopyWith<$Res> implements $RemoteDatabaseExceptionsCopyWith<$Res> {
  factory _$RemoteDatabaseNoDataFoundCopyWith(_RemoteDatabaseNoDataFound value, $Res Function(_RemoteDatabaseNoDataFound) _then) = __$RemoteDatabaseNoDataFoundCopyWithImpl;
@override @useResult
$Res call({
 dynamic error
});




}
/// @nodoc
class __$RemoteDatabaseNoDataFoundCopyWithImpl<$Res>
    implements _$RemoteDatabaseNoDataFoundCopyWith<$Res> {
  __$RemoteDatabaseNoDataFoundCopyWithImpl(this._self, this._then);

  final _RemoteDatabaseNoDataFound _self;
  final $Res Function(_RemoteDatabaseNoDataFound) _then;

/// Create a copy of RemoteDatabaseExceptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? error = freezed,}) {
  return _then(_RemoteDatabaseNoDataFound(
freezed == error ? _self.error : error // ignore: cast_nullable_to_non_nullable
as dynamic,
  ));
}


}

// dart format on
