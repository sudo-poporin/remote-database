// GENERATED CODE - DO NOT MODIFY BY HAND
// coverage:ignore-file
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'auth_exceptions.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;
/// @nodoc
mixin _$RemoteAuthExceptions {





@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is RemoteAuthExceptions);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString() {
  return 'RemoteAuthExceptions()';
}


}

/// @nodoc
class $RemoteAuthExceptionsCopyWith<$Res>  {
$RemoteAuthExceptionsCopyWith(RemoteAuthExceptions _, $Res Function(RemoteAuthExceptions) __);
}


/// Adds pattern-matching-related methods to [RemoteAuthExceptions].
extension RemoteAuthExceptionsPatterns on RemoteAuthExceptions {
/// A variant of `map` that fallback to returning `orElse`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeMap<TResult extends Object?>({TResult Function( RemoteAuthSignInFailure value)?  signInFailure,TResult Function( RemoteAuthSignUpFailure value)?  signUpFailure,TResult Function( RemoteAuthSignOutFailure value)?  signOutFailure,TResult Function( RemoteAuthPasswordResetFailure value)?  passwordResetFailure,TResult Function( RemoteAuthOtpVerificationFailure value)?  otpVerificationFailure,TResult Function( RemoteAuthUpdateUserFailure value)?  updateUserFailure,TResult Function( RemoteAuthInvalidCredentials value)?  invalidCredentials,TResult Function( RemoteAuthEmailNotConfirmed value)?  emailNotConfirmed,TResult Function( RemoteAuthUserAlreadyExists value)?  userAlreadyExists,TResult Function( RemoteAuthSessionExpired value)?  sessionExpired,TResult Function( RemoteAuthUnknown value)?  unknown,required TResult orElse(),}){
final _that = this;
switch (_that) {
case RemoteAuthSignInFailure() when signInFailure != null:
return signInFailure(_that);case RemoteAuthSignUpFailure() when signUpFailure != null:
return signUpFailure(_that);case RemoteAuthSignOutFailure() when signOutFailure != null:
return signOutFailure(_that);case RemoteAuthPasswordResetFailure() when passwordResetFailure != null:
return passwordResetFailure(_that);case RemoteAuthOtpVerificationFailure() when otpVerificationFailure != null:
return otpVerificationFailure(_that);case RemoteAuthUpdateUserFailure() when updateUserFailure != null:
return updateUserFailure(_that);case RemoteAuthInvalidCredentials() when invalidCredentials != null:
return invalidCredentials(_that);case RemoteAuthEmailNotConfirmed() when emailNotConfirmed != null:
return emailNotConfirmed(_that);case RemoteAuthUserAlreadyExists() when userAlreadyExists != null:
return userAlreadyExists(_that);case RemoteAuthSessionExpired() when sessionExpired != null:
return sessionExpired(_that);case RemoteAuthUnknown() when unknown != null:
return unknown(_that);case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// Callbacks receives the raw object, upcasted.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case final Subclass2 value:
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult map<TResult extends Object?>({required TResult Function( RemoteAuthSignInFailure value)  signInFailure,required TResult Function( RemoteAuthSignUpFailure value)  signUpFailure,required TResult Function( RemoteAuthSignOutFailure value)  signOutFailure,required TResult Function( RemoteAuthPasswordResetFailure value)  passwordResetFailure,required TResult Function( RemoteAuthOtpVerificationFailure value)  otpVerificationFailure,required TResult Function( RemoteAuthUpdateUserFailure value)  updateUserFailure,required TResult Function( RemoteAuthInvalidCredentials value)  invalidCredentials,required TResult Function( RemoteAuthEmailNotConfirmed value)  emailNotConfirmed,required TResult Function( RemoteAuthUserAlreadyExists value)  userAlreadyExists,required TResult Function( RemoteAuthSessionExpired value)  sessionExpired,required TResult Function( RemoteAuthUnknown value)  unknown,}){
final _that = this;
switch (_that) {
case RemoteAuthSignInFailure():
return signInFailure(_that);case RemoteAuthSignUpFailure():
return signUpFailure(_that);case RemoteAuthSignOutFailure():
return signOutFailure(_that);case RemoteAuthPasswordResetFailure():
return passwordResetFailure(_that);case RemoteAuthOtpVerificationFailure():
return otpVerificationFailure(_that);case RemoteAuthUpdateUserFailure():
return updateUserFailure(_that);case RemoteAuthInvalidCredentials():
return invalidCredentials(_that);case RemoteAuthEmailNotConfirmed():
return emailNotConfirmed(_that);case RemoteAuthUserAlreadyExists():
return userAlreadyExists(_that);case RemoteAuthSessionExpired():
return sessionExpired(_that);case RemoteAuthUnknown():
return unknown(_that);case _:
  throw StateError('Unexpected subclass');

}
}
/// A variant of `map` that fallback to returning `null`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? mapOrNull<TResult extends Object?>({TResult? Function( RemoteAuthSignInFailure value)?  signInFailure,TResult? Function( RemoteAuthSignUpFailure value)?  signUpFailure,TResult? Function( RemoteAuthSignOutFailure value)?  signOutFailure,TResult? Function( RemoteAuthPasswordResetFailure value)?  passwordResetFailure,TResult? Function( RemoteAuthOtpVerificationFailure value)?  otpVerificationFailure,TResult? Function( RemoteAuthUpdateUserFailure value)?  updateUserFailure,TResult? Function( RemoteAuthInvalidCredentials value)?  invalidCredentials,TResult? Function( RemoteAuthEmailNotConfirmed value)?  emailNotConfirmed,TResult? Function( RemoteAuthUserAlreadyExists value)?  userAlreadyExists,TResult? Function( RemoteAuthSessionExpired value)?  sessionExpired,TResult? Function( RemoteAuthUnknown value)?  unknown,}){
final _that = this;
switch (_that) {
case RemoteAuthSignInFailure() when signInFailure != null:
return signInFailure(_that);case RemoteAuthSignUpFailure() when signUpFailure != null:
return signUpFailure(_that);case RemoteAuthSignOutFailure() when signOutFailure != null:
return signOutFailure(_that);case RemoteAuthPasswordResetFailure() when passwordResetFailure != null:
return passwordResetFailure(_that);case RemoteAuthOtpVerificationFailure() when otpVerificationFailure != null:
return otpVerificationFailure(_that);case RemoteAuthUpdateUserFailure() when updateUserFailure != null:
return updateUserFailure(_that);case RemoteAuthInvalidCredentials() when invalidCredentials != null:
return invalidCredentials(_that);case RemoteAuthEmailNotConfirmed() when emailNotConfirmed != null:
return emailNotConfirmed(_that);case RemoteAuthUserAlreadyExists() when userAlreadyExists != null:
return userAlreadyExists(_that);case RemoteAuthSessionExpired() when sessionExpired != null:
return sessionExpired(_that);case RemoteAuthUnknown() when unknown != null:
return unknown(_that);case _:
  return null;

}
}
/// A variant of `when` that fallback to an `orElse` callback.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeWhen<TResult extends Object?>({TResult Function( String message,  int? statusCode)?  signInFailure,TResult Function( String message,  int? statusCode)?  signUpFailure,TResult Function( String message)?  signOutFailure,TResult Function( String message)?  passwordResetFailure,TResult Function( String message)?  otpVerificationFailure,TResult Function( String message)?  updateUserFailure,TResult Function()?  invalidCredentials,TResult Function()?  emailNotConfirmed,TResult Function()?  userAlreadyExists,TResult Function()?  sessionExpired,TResult Function( String message)?  unknown,required TResult orElse(),}) {final _that = this;
switch (_that) {
case RemoteAuthSignInFailure() when signInFailure != null:
return signInFailure(_that.message,_that.statusCode);case RemoteAuthSignUpFailure() when signUpFailure != null:
return signUpFailure(_that.message,_that.statusCode);case RemoteAuthSignOutFailure() when signOutFailure != null:
return signOutFailure(_that.message);case RemoteAuthPasswordResetFailure() when passwordResetFailure != null:
return passwordResetFailure(_that.message);case RemoteAuthOtpVerificationFailure() when otpVerificationFailure != null:
return otpVerificationFailure(_that.message);case RemoteAuthUpdateUserFailure() when updateUserFailure != null:
return updateUserFailure(_that.message);case RemoteAuthInvalidCredentials() when invalidCredentials != null:
return invalidCredentials();case RemoteAuthEmailNotConfirmed() when emailNotConfirmed != null:
return emailNotConfirmed();case RemoteAuthUserAlreadyExists() when userAlreadyExists != null:
return userAlreadyExists();case RemoteAuthSessionExpired() when sessionExpired != null:
return sessionExpired();case RemoteAuthUnknown() when unknown != null:
return unknown(_that.message);case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// As opposed to `map`, this offers destructuring.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case Subclass2(:final field2):
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult when<TResult extends Object?>({required TResult Function( String message,  int? statusCode)  signInFailure,required TResult Function( String message,  int? statusCode)  signUpFailure,required TResult Function( String message)  signOutFailure,required TResult Function( String message)  passwordResetFailure,required TResult Function( String message)  otpVerificationFailure,required TResult Function( String message)  updateUserFailure,required TResult Function()  invalidCredentials,required TResult Function()  emailNotConfirmed,required TResult Function()  userAlreadyExists,required TResult Function()  sessionExpired,required TResult Function( String message)  unknown,}) {final _that = this;
switch (_that) {
case RemoteAuthSignInFailure():
return signInFailure(_that.message,_that.statusCode);case RemoteAuthSignUpFailure():
return signUpFailure(_that.message,_that.statusCode);case RemoteAuthSignOutFailure():
return signOutFailure(_that.message);case RemoteAuthPasswordResetFailure():
return passwordResetFailure(_that.message);case RemoteAuthOtpVerificationFailure():
return otpVerificationFailure(_that.message);case RemoteAuthUpdateUserFailure():
return updateUserFailure(_that.message);case RemoteAuthInvalidCredentials():
return invalidCredentials();case RemoteAuthEmailNotConfirmed():
return emailNotConfirmed();case RemoteAuthUserAlreadyExists():
return userAlreadyExists();case RemoteAuthSessionExpired():
return sessionExpired();case RemoteAuthUnknown():
return unknown(_that.message);case _:
  throw StateError('Unexpected subclass');

}
}
/// A variant of `when` that fallback to returning `null`
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? whenOrNull<TResult extends Object?>({TResult? Function( String message,  int? statusCode)?  signInFailure,TResult? Function( String message,  int? statusCode)?  signUpFailure,TResult? Function( String message)?  signOutFailure,TResult? Function( String message)?  passwordResetFailure,TResult? Function( String message)?  otpVerificationFailure,TResult? Function( String message)?  updateUserFailure,TResult? Function()?  invalidCredentials,TResult? Function()?  emailNotConfirmed,TResult? Function()?  userAlreadyExists,TResult? Function()?  sessionExpired,TResult? Function( String message)?  unknown,}) {final _that = this;
switch (_that) {
case RemoteAuthSignInFailure() when signInFailure != null:
return signInFailure(_that.message,_that.statusCode);case RemoteAuthSignUpFailure() when signUpFailure != null:
return signUpFailure(_that.message,_that.statusCode);case RemoteAuthSignOutFailure() when signOutFailure != null:
return signOutFailure(_that.message);case RemoteAuthPasswordResetFailure() when passwordResetFailure != null:
return passwordResetFailure(_that.message);case RemoteAuthOtpVerificationFailure() when otpVerificationFailure != null:
return otpVerificationFailure(_that.message);case RemoteAuthUpdateUserFailure() when updateUserFailure != null:
return updateUserFailure(_that.message);case RemoteAuthInvalidCredentials() when invalidCredentials != null:
return invalidCredentials();case RemoteAuthEmailNotConfirmed() when emailNotConfirmed != null:
return emailNotConfirmed();case RemoteAuthUserAlreadyExists() when userAlreadyExists != null:
return userAlreadyExists();case RemoteAuthSessionExpired() when sessionExpired != null:
return sessionExpired();case RemoteAuthUnknown() when unknown != null:
return unknown(_that.message);case _:
  return null;

}
}

}

/// @nodoc


class RemoteAuthSignInFailure implements RemoteAuthExceptions {
  const RemoteAuthSignInFailure({required this.message, this.statusCode});
  

 final  String message;
 final  int? statusCode;

/// Create a copy of RemoteAuthExceptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$RemoteAuthSignInFailureCopyWith<RemoteAuthSignInFailure> get copyWith => _$RemoteAuthSignInFailureCopyWithImpl<RemoteAuthSignInFailure>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is RemoteAuthSignInFailure&&(identical(other.message, message) || other.message == message)&&(identical(other.statusCode, statusCode) || other.statusCode == statusCode));
}


@override
int get hashCode => Object.hash(runtimeType,message,statusCode);

@override
String toString() {
  return 'RemoteAuthExceptions.signInFailure(message: $message, statusCode: $statusCode)';
}


}

/// @nodoc
abstract mixin class $RemoteAuthSignInFailureCopyWith<$Res> implements $RemoteAuthExceptionsCopyWith<$Res> {
  factory $RemoteAuthSignInFailureCopyWith(RemoteAuthSignInFailure value, $Res Function(RemoteAuthSignInFailure) _then) = _$RemoteAuthSignInFailureCopyWithImpl;
@useResult
$Res call({
 String message, int? statusCode
});




}
/// @nodoc
class _$RemoteAuthSignInFailureCopyWithImpl<$Res>
    implements $RemoteAuthSignInFailureCopyWith<$Res> {
  _$RemoteAuthSignInFailureCopyWithImpl(this._self, this._then);

  final RemoteAuthSignInFailure _self;
  final $Res Function(RemoteAuthSignInFailure) _then;

/// Create a copy of RemoteAuthExceptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? message = null,Object? statusCode = freezed,}) {
  return _then(RemoteAuthSignInFailure(
message: null == message ? _self.message : message // ignore: cast_nullable_to_non_nullable
as String,statusCode: freezed == statusCode ? _self.statusCode : statusCode // ignore: cast_nullable_to_non_nullable
as int?,
  ));
}


}

/// @nodoc


class RemoteAuthSignUpFailure implements RemoteAuthExceptions {
  const RemoteAuthSignUpFailure({required this.message, this.statusCode});
  

 final  String message;
 final  int? statusCode;

/// Create a copy of RemoteAuthExceptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$RemoteAuthSignUpFailureCopyWith<RemoteAuthSignUpFailure> get copyWith => _$RemoteAuthSignUpFailureCopyWithImpl<RemoteAuthSignUpFailure>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is RemoteAuthSignUpFailure&&(identical(other.message, message) || other.message == message)&&(identical(other.statusCode, statusCode) || other.statusCode == statusCode));
}


@override
int get hashCode => Object.hash(runtimeType,message,statusCode);

@override
String toString() {
  return 'RemoteAuthExceptions.signUpFailure(message: $message, statusCode: $statusCode)';
}


}

/// @nodoc
abstract mixin class $RemoteAuthSignUpFailureCopyWith<$Res> implements $RemoteAuthExceptionsCopyWith<$Res> {
  factory $RemoteAuthSignUpFailureCopyWith(RemoteAuthSignUpFailure value, $Res Function(RemoteAuthSignUpFailure) _then) = _$RemoteAuthSignUpFailureCopyWithImpl;
@useResult
$Res call({
 String message, int? statusCode
});




}
/// @nodoc
class _$RemoteAuthSignUpFailureCopyWithImpl<$Res>
    implements $RemoteAuthSignUpFailureCopyWith<$Res> {
  _$RemoteAuthSignUpFailureCopyWithImpl(this._self, this._then);

  final RemoteAuthSignUpFailure _self;
  final $Res Function(RemoteAuthSignUpFailure) _then;

/// Create a copy of RemoteAuthExceptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? message = null,Object? statusCode = freezed,}) {
  return _then(RemoteAuthSignUpFailure(
message: null == message ? _self.message : message // ignore: cast_nullable_to_non_nullable
as String,statusCode: freezed == statusCode ? _self.statusCode : statusCode // ignore: cast_nullable_to_non_nullable
as int?,
  ));
}


}

/// @nodoc


class RemoteAuthSignOutFailure implements RemoteAuthExceptions {
  const RemoteAuthSignOutFailure({required this.message});
  

 final  String message;

/// Create a copy of RemoteAuthExceptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$RemoteAuthSignOutFailureCopyWith<RemoteAuthSignOutFailure> get copyWith => _$RemoteAuthSignOutFailureCopyWithImpl<RemoteAuthSignOutFailure>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is RemoteAuthSignOutFailure&&(identical(other.message, message) || other.message == message));
}


@override
int get hashCode => Object.hash(runtimeType,message);

@override
String toString() {
  return 'RemoteAuthExceptions.signOutFailure(message: $message)';
}


}

/// @nodoc
abstract mixin class $RemoteAuthSignOutFailureCopyWith<$Res> implements $RemoteAuthExceptionsCopyWith<$Res> {
  factory $RemoteAuthSignOutFailureCopyWith(RemoteAuthSignOutFailure value, $Res Function(RemoteAuthSignOutFailure) _then) = _$RemoteAuthSignOutFailureCopyWithImpl;
@useResult
$Res call({
 String message
});




}
/// @nodoc
class _$RemoteAuthSignOutFailureCopyWithImpl<$Res>
    implements $RemoteAuthSignOutFailureCopyWith<$Res> {
  _$RemoteAuthSignOutFailureCopyWithImpl(this._self, this._then);

  final RemoteAuthSignOutFailure _self;
  final $Res Function(RemoteAuthSignOutFailure) _then;

/// Create a copy of RemoteAuthExceptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? message = null,}) {
  return _then(RemoteAuthSignOutFailure(
message: null == message ? _self.message : message // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}

/// @nodoc


class RemoteAuthPasswordResetFailure implements RemoteAuthExceptions {
  const RemoteAuthPasswordResetFailure({required this.message});
  

 final  String message;

/// Create a copy of RemoteAuthExceptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$RemoteAuthPasswordResetFailureCopyWith<RemoteAuthPasswordResetFailure> get copyWith => _$RemoteAuthPasswordResetFailureCopyWithImpl<RemoteAuthPasswordResetFailure>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is RemoteAuthPasswordResetFailure&&(identical(other.message, message) || other.message == message));
}


@override
int get hashCode => Object.hash(runtimeType,message);

@override
String toString() {
  return 'RemoteAuthExceptions.passwordResetFailure(message: $message)';
}


}

/// @nodoc
abstract mixin class $RemoteAuthPasswordResetFailureCopyWith<$Res> implements $RemoteAuthExceptionsCopyWith<$Res> {
  factory $RemoteAuthPasswordResetFailureCopyWith(RemoteAuthPasswordResetFailure value, $Res Function(RemoteAuthPasswordResetFailure) _then) = _$RemoteAuthPasswordResetFailureCopyWithImpl;
@useResult
$Res call({
 String message
});




}
/// @nodoc
class _$RemoteAuthPasswordResetFailureCopyWithImpl<$Res>
    implements $RemoteAuthPasswordResetFailureCopyWith<$Res> {
  _$RemoteAuthPasswordResetFailureCopyWithImpl(this._self, this._then);

  final RemoteAuthPasswordResetFailure _self;
  final $Res Function(RemoteAuthPasswordResetFailure) _then;

/// Create a copy of RemoteAuthExceptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? message = null,}) {
  return _then(RemoteAuthPasswordResetFailure(
message: null == message ? _self.message : message // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}

/// @nodoc


class RemoteAuthOtpVerificationFailure implements RemoteAuthExceptions {
  const RemoteAuthOtpVerificationFailure({required this.message});
  

 final  String message;

/// Create a copy of RemoteAuthExceptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$RemoteAuthOtpVerificationFailureCopyWith<RemoteAuthOtpVerificationFailure> get copyWith => _$RemoteAuthOtpVerificationFailureCopyWithImpl<RemoteAuthOtpVerificationFailure>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is RemoteAuthOtpVerificationFailure&&(identical(other.message, message) || other.message == message));
}


@override
int get hashCode => Object.hash(runtimeType,message);

@override
String toString() {
  return 'RemoteAuthExceptions.otpVerificationFailure(message: $message)';
}


}

/// @nodoc
abstract mixin class $RemoteAuthOtpVerificationFailureCopyWith<$Res> implements $RemoteAuthExceptionsCopyWith<$Res> {
  factory $RemoteAuthOtpVerificationFailureCopyWith(RemoteAuthOtpVerificationFailure value, $Res Function(RemoteAuthOtpVerificationFailure) _then) = _$RemoteAuthOtpVerificationFailureCopyWithImpl;
@useResult
$Res call({
 String message
});




}
/// @nodoc
class _$RemoteAuthOtpVerificationFailureCopyWithImpl<$Res>
    implements $RemoteAuthOtpVerificationFailureCopyWith<$Res> {
  _$RemoteAuthOtpVerificationFailureCopyWithImpl(this._self, this._then);

  final RemoteAuthOtpVerificationFailure _self;
  final $Res Function(RemoteAuthOtpVerificationFailure) _then;

/// Create a copy of RemoteAuthExceptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? message = null,}) {
  return _then(RemoteAuthOtpVerificationFailure(
message: null == message ? _self.message : message // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}

/// @nodoc


class RemoteAuthUpdateUserFailure implements RemoteAuthExceptions {
  const RemoteAuthUpdateUserFailure({required this.message});
  

 final  String message;

/// Create a copy of RemoteAuthExceptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$RemoteAuthUpdateUserFailureCopyWith<RemoteAuthUpdateUserFailure> get copyWith => _$RemoteAuthUpdateUserFailureCopyWithImpl<RemoteAuthUpdateUserFailure>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is RemoteAuthUpdateUserFailure&&(identical(other.message, message) || other.message == message));
}


@override
int get hashCode => Object.hash(runtimeType,message);

@override
String toString() {
  return 'RemoteAuthExceptions.updateUserFailure(message: $message)';
}


}

/// @nodoc
abstract mixin class $RemoteAuthUpdateUserFailureCopyWith<$Res> implements $RemoteAuthExceptionsCopyWith<$Res> {
  factory $RemoteAuthUpdateUserFailureCopyWith(RemoteAuthUpdateUserFailure value, $Res Function(RemoteAuthUpdateUserFailure) _then) = _$RemoteAuthUpdateUserFailureCopyWithImpl;
@useResult
$Res call({
 String message
});




}
/// @nodoc
class _$RemoteAuthUpdateUserFailureCopyWithImpl<$Res>
    implements $RemoteAuthUpdateUserFailureCopyWith<$Res> {
  _$RemoteAuthUpdateUserFailureCopyWithImpl(this._self, this._then);

  final RemoteAuthUpdateUserFailure _self;
  final $Res Function(RemoteAuthUpdateUserFailure) _then;

/// Create a copy of RemoteAuthExceptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? message = null,}) {
  return _then(RemoteAuthUpdateUserFailure(
message: null == message ? _self.message : message // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}

/// @nodoc


class RemoteAuthInvalidCredentials implements RemoteAuthExceptions {
  const RemoteAuthInvalidCredentials();
  






@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is RemoteAuthInvalidCredentials);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString() {
  return 'RemoteAuthExceptions.invalidCredentials()';
}


}




/// @nodoc


class RemoteAuthEmailNotConfirmed implements RemoteAuthExceptions {
  const RemoteAuthEmailNotConfirmed();
  






@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is RemoteAuthEmailNotConfirmed);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString() {
  return 'RemoteAuthExceptions.emailNotConfirmed()';
}


}




/// @nodoc


class RemoteAuthUserAlreadyExists implements RemoteAuthExceptions {
  const RemoteAuthUserAlreadyExists();
  






@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is RemoteAuthUserAlreadyExists);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString() {
  return 'RemoteAuthExceptions.userAlreadyExists()';
}


}




/// @nodoc


class RemoteAuthSessionExpired implements RemoteAuthExceptions {
  const RemoteAuthSessionExpired();
  






@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is RemoteAuthSessionExpired);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString() {
  return 'RemoteAuthExceptions.sessionExpired()';
}


}




/// @nodoc


class RemoteAuthUnknown implements RemoteAuthExceptions {
  const RemoteAuthUnknown({required this.message});
  

 final  String message;

/// Create a copy of RemoteAuthExceptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$RemoteAuthUnknownCopyWith<RemoteAuthUnknown> get copyWith => _$RemoteAuthUnknownCopyWithImpl<RemoteAuthUnknown>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is RemoteAuthUnknown&&(identical(other.message, message) || other.message == message));
}


@override
int get hashCode => Object.hash(runtimeType,message);

@override
String toString() {
  return 'RemoteAuthExceptions.unknown(message: $message)';
}


}

/// @nodoc
abstract mixin class $RemoteAuthUnknownCopyWith<$Res> implements $RemoteAuthExceptionsCopyWith<$Res> {
  factory $RemoteAuthUnknownCopyWith(RemoteAuthUnknown value, $Res Function(RemoteAuthUnknown) _then) = _$RemoteAuthUnknownCopyWithImpl;
@useResult
$Res call({
 String message
});




}
/// @nodoc
class _$RemoteAuthUnknownCopyWithImpl<$Res>
    implements $RemoteAuthUnknownCopyWith<$Res> {
  _$RemoteAuthUnknownCopyWithImpl(this._self, this._then);

  final RemoteAuthUnknown _self;
  final $Res Function(RemoteAuthUnknown) _then;

/// Create a copy of RemoteAuthExceptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? message = null,}) {
  return _then(RemoteAuthUnknown(
message: null == message ? _self.message : message // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}

// dart format on
